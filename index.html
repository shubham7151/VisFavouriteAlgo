<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <style>
        #maxFlowDisplay {
            font-size: 20px;
            margin-top: 10px;
            text-align: center;
        }
        #selectedItemDisplay {
            font-size: 20px;
            margin-top: 10px;
            text-align: center;
        }
        .circleGreen {
            width: 50px;
            height: 50px;
            background-color: RGB(0,255,0);
            border-radius: 50%;
            align-items: center;
        }
        .circleRed {
            width: 50px;
            height: 50px;
            background-color: RGB(255,0,0);
            border-radius: 50%;
            align-items: center;
        }
    </style>
</head>
<body>
<div>
    <div class="container">
        <h1 style="text-align: center;">
            Edmondsâ€“Karp Algorithm
        </h1>
        <h3>Instruction</h3>
        <div class="row">
            <div class="col-sm">
                <ul>
                    <li>Right Click to add nodes</li>
                    <li>Left Click and drag to add edges</li>
                    <li>Select node and press "Shift + S" to make it Source</li>
                    <li>Select node and press "Shift + T" to make it Sink</li>
                </ul>
            </div>
            <div class="col-sm">
                <div>
                    <div class="circleGreen"></div>Source
                    <div class="circleRed"></div>Sink
                </div>
            </div>
        </div>
        
        <button class="btn btn-primary" onclick="startAlgorithm()">Start Algorithm</button>
        <button class="btn btn-primary" onclick="window.location.reload()">Reset</button>
        <button class="btn btn-primary" onclick="showSteps()">Show Steps</button>
        <div class="form-group">
            <label for="capacityInput">Set Capacity:</label>
            <input type="number" class="form-control" id="capacityInput" placeholder="Enter capacity">
            <button class="btn btn-primary" onclick="setCapacity()">Set Capacity</button>
        </div>
    </div>
    <div id="maxFlowDisplay">Max Flow: 0</div>
    <div id="selectedItemDisplay">Selected Item: None</div>
</div>

<script>
document.addEventListener('contextmenu', event => event.preventDefault());

let nodes = [];
let edges = [];
let capacities = [];
let flows = [];
let source = -1;
let sink = -1;
let maxFlow = 0;
let iterationSteps = [];
let stepIndex = 0;
let isDragging = false;
let startNodeIndex = -1;
let selectedNode = -1;
let selectedEdge = null;
let showStepsInterval;

function setup() {
    let canvas = createCanvas(1750, 700);
    noLoop();
    canvas.elt.addEventListener('contextmenu', event => event.preventDefault());
}

function draw() {
    background(255);
    drawGraph();
    drawBoundary();
}

function drawBoundary() {
    noFill();
    stroke(0);
    rect(0, 0, width - 1, height - 1);
}

function mousePressed() {
    if (mouseButton === RIGHT) {
        addVertex(mouseX, mouseY);
    } else if (mouseButton === LEFT) {
        if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {
            let nodeIndex = getNodeIndexAtPosition(mouseX, mouseY);
            if (nodeIndex !== -1) {
                isDragging = true;
                startNodeIndex = nodeIndex;
                selectedNode = nodeIndex;
                selectedEdge = null;
                updateSelectedItemDisplay();
            } else {
                let edgeIndex = getEdgeIndexAtPosition(mouseX, mouseY);
                if (edgeIndex !== -1) {
                    selectedEdge = edges[edgeIndex];
                    selectedNode = -1; // Deselect node if edge is selected
                    updateSelectedItemDisplay();
                } else {
                    selectedNode = -1;
                    selectedEdge = null;
                    updateSelectedItemDisplay();
                }
            }
            redraw();
        }
    }
}

function mouseReleased() {
    if (isDragging && mouseButton === LEFT) {
        let endNodeIndex = getNodeIndexAtPosition(mouseX, mouseY);
        if (startNodeIndex !== -1 && endNodeIndex !== -1 && startNodeIndex !== endNodeIndex) {
            addEdge(startNodeIndex, endNodeIndex, 0); // Add edge with initial capacity 0
        }
        isDragging = false;
        startNodeIndex = -1;
        redraw();
    }
}

function doubleClicked() {
    let nodeIndex = getNodeIndexAtPosition(mouseX, mouseY);
    if (nodeIndex !== -1) {
        source = nodeIndex;
        redraw();
    }
}

function keyPressed() {
    if (key === 'S' && keyIsDown(SHIFT)) {
        let nodeIndex = getNodeIndexAtPosition(mouseX, mouseY);
        if (nodeIndex !== -1) {
            source = nodeIndex;
            redraw();
        }
    } else if (key === 'T' && keyIsDown(SHIFT)) {
        let nodeIndex = getNodeIndexAtPosition(mouseX, mouseY);
        if (nodeIndex !== -1) {
            sink = nodeIndex;
            redraw();
        }
    }
}

function addVertex(x, y) {
    nodes.push({ x: x, y: y });
    updateCapacitiesMatrix();
    redraw();
}

function addEdge(from, to, capacity) {
    capacities[from][to] = capacity;
    edges.push({ from: from, to: to, capacity: capacity });
    redraw();
}

function setCapacity() {
    if (selectedEdge !== null) {
        let capacity = document.getElementById('capacityInput').value;
        if (capacity !== null && capacity !== "") {
            capacities[selectedEdge.from][selectedEdge.to] = parseInt(capacity);
            selectedEdge.capacity = parseInt(capacity);
            redraw();
        }
    } else {
        alert("Please select an edge to set the capacity.");
    }
}

function startAlgorithm() {
    if (source === -1 || sink === -1) {
        alert("Please set both a source and a sink.");
        return;
    }
    maxFlow = 0;
    flows = capacities.map(row => row.map(val => 0));
    iterationSteps = [];
    console.log("Starting Edmonds-Karp Algorithm...");
    edmondsKarp(source, sink);
    document.getElementById('maxFlowDisplay').innerText = "Max Flow: " + maxFlow;
    console.log("Max Flow: " + maxFlow);
}

function showSteps() {
    if (iterationSteps.length === 0) {
        console.log("No steps recorded. Please run the algorithm first.");
        return;
    }
    stepIndex = 0;
    clearInterval(showStepsInterval);
    showStepsInterval = setInterval(() => {
        if (stepIndex < iterationSteps.length) {
            flows = iterationSteps[stepIndex].flows;
            highlightPath(iterationSteps[stepIndex].path);
            
            setTimeout(() => {
                console.log("Step " + (stepIndex + 1) + ": Path - ", iterationSteps[stepIndex].path);
                stepIndex++;
                redraw();
            }, 2000);
            // console.log("Step " + (stepIndex + 1) + ": Path - ", iterationSteps[stepIndex].path);
            // stepIndex++;
            // redraw();
        } else {
            clearInterval(showStepsInterval);
        }
    }, 4000);
}

function updateCapacitiesMatrix() {
    capacities = Array(nodes.length).fill().map(() => Array(nodes.length).fill(0));
    flows = Array(nodes.length).fill().map(() => Array(nodes.length).fill(0));
    edges.forEach(edge => {
        capacities[edge.from][edge.to] = edge.capacity;
    });
}

function drawGraph() {
    noStroke();
    for (let edge of edges) {
        let fromNode = nodes[edge.from];
        let toNode = nodes[edge.to];
        
        let directionX = toNode.x - fromNode.x;
        let directionY = toNode.y - fromNode.y;
        let edgeLength = sqrt(directionX * directionX + directionY * directionY);
        let unitX = directionX / edgeLength;
        let unitY = directionY / edgeLength;

        let arrowSize = 10;
        let arrowX = toNode.x - unitX * arrowSize * 2;
        let arrowY = toNode.y - unitY * arrowSize * 2;

        if (edge === selectedEdge) {
            stroke(255, 0, 0); // Highlight selected edge in red
        } else {
            stroke(0, 100, 200);
        }
        strokeWeight(2);
        line(fromNode.x, fromNode.y, toNode.x, toNode.y);

        push();
        translate(arrowX, arrowY);
        rotate(atan2(directionY, directionX));
        if (edge === selectedEdge) {
            fill(255, 0, 0); // Highlight arrow of selected edge in red
        } else {
            fill(0, 100, 200);
        }
        triangle(-arrowSize, -arrowSize / 2, -arrowSize, arrowSize / 2, 0, 0);
        pop();

        let midX = (fromNode.x + toNode.x) / 2;
        let midY = (fromNode.y + toNode.y) / 2;
        noStroke();
        fill(0);
        textSize(14); // Default text size for non-highlighted edges
        textStyle(NORMAL)
        text(flows[edge.from][edge.to] + "/" + capacities[edge.from][edge.to], midX + 10, midY + 10); // Display flow/capacity
    }

    for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        fill(255);
        stroke(0);
        strokeWeight(1);
        if (i === source) {
            fill(0, 255, 0);
        } else if (i === sink) {
            fill(255, 0, 0);
        } else {
            fill(255);
        }
        ellipse(node.x, node.y, 40, 40);
    }

    if (isDragging && startNodeIndex !== -1) {
        let startNode = nodes[startNodeIndex];
        stroke(150);
        line(startNode.x, startNode.y, mouseX, mouseY);
    }
}

function highlightPath(path) {
    for (let i = 0; i < path.length - 1; i++) {
        let fromNode = nodes[path[i]];
        let toNode = nodes[path[i + 1]];
        
        let directionX = toNode.x - fromNode.x;
        let directionY = toNode.y - fromNode.y;
        let edgeLength = sqrt(directionX * directionX + directionY * directionY);
        let unitX = directionX / edgeLength;
        let unitY = directionY / edgeLength;

        let arrowSize = 10;
        let arrowX = toNode.x - unitX * arrowSize * 2;
        let arrowY = toNode.y - unitY * arrowSize * 2;

        stroke(255, 0, 255); // Highlight path in green
        strokeWeight(4);
        line(fromNode.x, fromNode.y, toNode.x, toNode.y);

        push();
        translate(arrowX, arrowY);
        rotate(atan2(directionY, directionX));
        fill(0, 255, 0); // Highlight arrow of path in green
        triangle(-arrowSize, -arrowSize / 2, -arrowSize, arrowSize / 2, 0, 0);
        pop();

        let midX = (fromNode.x + toNode.x) / 2;
        let midY = (fromNode.y + toNode.y) / 2;
        noStroke();
        fill(0);
        textSize(16); // Increase text size
        textStyle(BOLD); // Bold text
        text(flows[path[i]][path[i + 1]] + "/" + capacities[path[i]][path[i + 1]], midX + 10, midY + 10);
    }
}

function getNodeIndexAtPosition(x, y) {
    for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        let d = dist(x, y, node.x, node.y);
        if (d < 20) {
            return i;
        }
    }
    return -1;
}

function getEdgeIndexAtPosition(x, y) {
    for (let i = 0; i < edges.length; i++) {
        let edge = edges[i];
        let fromNode = nodes[edge.from];
        let toNode = nodes[edge.to];

        let distance = distToSegment({ x, y }, fromNode, toNode);
        if (distance < 10) { // Tolerance for selecting edge
            return i;
        }
    }
    return -1;
}

function distToSegment(p, v, w) {
    let l2 = distSq(v, w);
    if (l2 === 0) return dist(p.x, p.y, v.x, v.y);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = max(0, min(1, t));
    return dist(p.x, p.y, v.x + t * (w.x - v.x), v.y + t * (w.y - v.y));
}

function distSq(v, w) {
    return (v.x - w.x) * (v.x - w.x) + (v.y - w.y) * (v.y - w.y);
}

function bfs(source, sink, parent) {
    let visited = new Array(nodes.length).fill(false);
    let queue = [];
    queue.push(source);
    visited[source] = true;
    parent[source] = -1;

    while (queue.length > 0) {
        let u = queue.shift();

        for (let v = 0; v < nodes.length; v++) {
            if (!visited[v] && capacities[u][v] - flows[u][v] > 0) {
                queue.push(v);
                parent[v] = u;
                visited[v] = true;
            }
        }
    }
    return visited[sink];
}

function edmondsKarp(source, sink) {
    let parent = new Array(nodes.length);

    while (bfs(source, sink, parent)) {
        let pathFlow = Infinity;
        let path = [];
        for (let v = sink; v != source; v = parent[v]) {
            path.push(v);
            let u = parent[v];
            pathFlow = min(pathFlow, capacities[u][v] - flows[u][v]);
        }
        path.push(source);
        path.reverse();

        for (let v = sink; v != source; v = parent[v]) {
            let u = parent[v];
            flows[u][v] += pathFlow;
            flows[v][u] -= pathFlow;
        }

        maxFlow += pathFlow;
        iterationSteps.push({ flows: JSON.parse(JSON.stringify(flows)), path: path });
        console.log("Path found: ", path, " with flow: ", pathFlow);
    }
}

function updateSelectedItemDisplay() {
    let selectedItemDisplay = document.getElementById('selectedItemDisplay');
    if (selectedNode !== -1) {
        selectedItemDisplay.innerText = "Selected Item: Node " + selectedNode;
    } else if (selectedEdge) {
        selectedItemDisplay.innerText = "Selected Item: Edge (" + selectedEdge.from + " -> " + selectedEdge.to + ")";
    } else {
        selectedItemDisplay.innerText = "Selected Item: None";
    }
}
</script>

<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
</body>
</html>
